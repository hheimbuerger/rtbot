Right now, these are only snippets. More documentation will be added later. (How many
projects broke that promise already? :D)

===========================================================================================================

Path structure:
/					Contains the BotManager.py, the starting code for the bot.
/debugging_pluins	Various plugins that aren't used in the production environment but for testing.
/exceptions (*)		XML files that are dumped for every exception detected in the repository. The
					filename contains the date, time and a running number per bot session.
/lib				3rd party modules necessary for running the bot.
/logs (*)			The logs created by the bot.
/modules			Core modules of the bot.
/plugins			Plugins for the bot.
/resources			Various resources needed by various plugins. Also used as a storage area for plugins.

(*) = Please do not commit the contents of these directories to the repository.

===========================================================================================================

Running the bot:
Windows:
	Run the BotManager.py. (Calling "python BotManager.py" might be necessary, depending on your setup.)
Linux:
	Run the BotManager.py with a control parameter: "python BotManager.py start",
		"python BotManager.py stop", "python BotManager.py restart"

===========================================================================================================

Terminology: [needs improvement]
  - nick: the unique id of a current user in the channel
  - user: the object to a nick currently in the channel -- users are always associated to nicks but can link to names!
  - account: an account of a user that can be in the channel or not
  - name: the unique id of a user that can be in the channel or not -- names are always associated to accounts and aren't linked to nicks (forwards)
 
REMARK: Names should be persistently treated as unique user identifiers. If a user with a known name shows up,
he's expected to treated as the user who previously had this name. Users switching names is unsupported behaviour
and doesn't have to be handled by the plugins.

===========================================================================================================

Known user attributes:
(Documentation of the attributes associated with the user object of a nick.)
  - timeOfLastWhoAttempt [temporary]: used to give the user a grace period to auth by password or
                                      hostmask before he's put under MODE control
  - numberOfWhoAttempts [temporary]: that many times I try to WHO you before I give up trying to get
                                     a result and just put you under MODE control without a hostmask
                                     (can happen when you change nicks between me issuing a WHO and me
                                     retrieving the WHO result)
  - authedAs: the account name I could auth you to by password or hostmask, the existence of this attribute
              means the last auth attempt (by password or hostmask) was successful
  - authedByPassword: the (encrypted) password you gave me, the existence of this attribute means the last
              auth attempt by password was successful
  - timeOfLastAuth: (datetime) ...
  - isPunished: (Boolean) are you currently in punish mode?
  - isMuted: (Boolean) are you currently muted?
  - group: (String, but shouldn't be set to a value outside the constants in AuthenticationPlugin::UserAccount)
           the permission group I could associate you with
  - passwordSetAuthorization: (dictionary) set when one user grants another to set a password, contains
                              the keys "timestamp", "account" and "sender"

===========================================================================================================

Plugin Development:

Event handler signatures:

## From IrcLib: ##
def onJoin(self, irclib, source):
def onChangeNick(self, irclib, source, target):
def onLeave(self, irclib, source):				 	# called *before* user list update!
def onKick(self, irclib, source, target, reason):	# called *before* user list update!
def onQuit(self, irclib, source, reason):			# called *before* user list update!
def onChannelMode(self, irclib, source, flags):
def onUserMode(self, irclib, source, targets, flags):
def onNotice(self, irclib, source, message):
def onChannelMessage(self, irclib, source, message):
def onChannelEmote(self, irclib, source, emote):
def onPrivateMessage(self, irclib, source, message):
def onPrivateEmote(self, irclib, source, emote):
def onChannelTopicChange(source, irclib, topic):
def onWhoResult(self, irclib, user):
def onWhoisResult(self, irclib, user):

## From HTTPServer: ##
## From RPCServer: ##

Brave New Bot (aka. RTBot Revolution aka. NYI aka ToDo):
The plugin contract:
* plugins declare their dependencies in a static method called getDependencies. This should return a list of strings that are the names of other plugin python modules. (eg. ["BarPlugin", "FooPlugin"]
* the plugins can't do anything with these dependencies in the constructor (__init__)
* after construction, the method/event onInitialise is called/fired if it exists. By this time, the plugin is guaranteed to have attributes corresponding to its dependencies injected. These attributes will have the same names as their modules, except that the first letter will be lower-case to follow the coding style. (eg. self.BarPlugin, self.FooPlugin)
* In addition, each plugin is guaranteed to have attributes corresponding to base modules:
    - irclib
    - httpserver
    - rpcserver
    - accountmanager
    - pluginInterface
* before being unloaded, the method dispose will be called on the plugin
* if an exception is raised during plugin execution, all plugins between the point of raising and the pluginInterface will be disabled for further investigation

===========================================================================================================

The database connection (activated by entering a connection string in Settings.database_connection_string)
requires MySQLdb (http://sourceforge.net/projects/mysqldb) and SQLObject (http://www.sqlobject.org/). It
is not necessary for running the bot, though (and deactivated by default).




/notice RTBotTest authenticate Cort tufer
#RollingThunder.development
